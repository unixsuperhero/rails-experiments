<item>
  <title>Reading Journal: Refactoring (Fowler) -- Habit Building</title>
  <link>http://unixsuperhero.com/2013/05/02/reading-journal-refactoring-fowler-habit-building/</link>
  <pubDate>Thu, 02 May 2013 06:01:41 +0000</pubDate>
  <guid isPermaLink="false">http://unixsuperhero.com/?p=352</guid>
  <content:encoded><![CDATA[<h1>Reading Journal - Refactoring: Improving the Design of Existing Code</h1><h2>Chapter 1 - Refactoring, a first example</h2><h3>1a. The starting point</h3><p>The book uses a movie rental app as the example program.</p><p>Initial refactorings are around Customer's statement() and htmlStatement() methods.</p><p><strong>Tip:</strong> If program design makes adding a feature inconvenient.  Refactor first, until the feature is convenient to add.</p><h3>1b. The first step in refactoring</h3><p>Write test cases for the code yet to be refactored.</p><p>Tests give you confidence that your changes haven't broken anything.</p><h3>1c. decomposing and redistributing the statement method</h3><p>Smaller pieces of code are more manageable.</p><p><strong>Goal:</strong> Write htmlStatement() without much code duplication from statement().</p><pre><span style="text-decoration:underline;">Pattern:</span> <strong>Extract Method<br /></strong>- Find a logical group of code within an existing method.  Create a new method with it.<br />- Look for local variables in code.  Pass variables from original method to newly extracted method as parameters.  If the extracted method changes the variable, return it to be reassigned in the original method.</pre><p><strong>Tip:</strong> Make small incremental changes, it is easier to identify where bugs were introduced.</p><p><strong>Tip:</strong> Use descriptive names for variables and methods.  Code should read like a story, or pseudo-code.</p><pre><span style="text-decoration:underline;">Pattern:</span> <strong>Move Method<br /></strong>- Use this pattern when a method is accessing a lot of data from a different class.<br />- Move an entire method from one class to the class with the data being accessed.<br />- Update all references to the new method.</pre><p> </p><pre><span style="text-decoration:underline;">Pattern:</span> <strong>Replace Temp with Query<br /></strong>- Instead of cluttering a method with a temp variable whose value doesn't change, call the method retrieving the value each place the temp variable is used.<br />- Downside, computations retrieving the value are performed on each method call (unless memoize cached).</pre><p><strong>Tip:</strong> Don't worry about performance when refactoring.  Worry about it when optimizing.</p><h3>1d. Replacing the conditional login on price code with polymorphism</h3><p>Don't have a switch checking an attribute on a class other than yourself.  Use Move Method in this case.</p><pre><span style="text-decoration:underline;">Pattern:</span><strong> Self-Encapsulate Field<br /></strong>- Create sets/gets for a field<br />- Only use these sets/gets to access field<br />- Make field private, preventing direct access</pre><pre><span style="text-decoration:underline;">Pattern:</span> <strong>Replace Type Code with State/Strategy</strong><br />- Self Encapsulate the Type Field<br />- Create a new class, name it after the type (UserType)<br />- Add a subclass for each type EliteUserType, DiningUserType<br />- Add getType() to UserType base class<br />- Override getType() in each subclass<br />- Type Code getter calls getType() on [Subclass]UserType<br />- Type Code setter sets proper Subclass</pre><pre><span style="text-decoration:underline;">Pattern:</span> <strong>Replace Conditional with Polymorphism<br /></strong>- Take each branch of the conditional, create a base class User, and subclasses for each branch ActiveUser, InactiveUser<br />- Create a method name similar to the method with the conditional in it.  User.get_benefits -&gt; ActiveUser.get_benefits; InactiveUser.get_benefits<br />- This way, getting benefits is not handled by logic, but language convention.</pre><pre>All Together:<br />- Method with conditional uses self-encapsulated getter<br />- Which returns the subclass<br />- Calls the method overwritten in that subclass executing only the code from that branch in the original conditional<br />e.g. (if) get_user_type returns ActiveUser, and that branch, calculates benefits, then the steps are:<br />def original_conditional_method<br />  get_user_type.get_benefits<br />  # get_user_type = ActiveUser (or InactiveUser based on the object)<br />  # return ActiveUser.get_benefits<br />end</pre><h3> 1e. Final Thoughts</h3><p>Refactoring rhythm: Test, Small Change, Test, Small Change, Test...</p>]]></content:encoded>
  <wp:post_id>352</wp:post_id>
  <wp:post_date>2013-05-02 06:01:41</wp:post_date>
  <wp:post_date_gmt>2013-05-02 06:01:41</wp:post_date_gmt>
  <wp:post_name>reading-journal-refactoring-fowler-habit-building</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_type>post</wp:post_type>
  <wp:post_password></wp:post_password>
  <TAGS>
  book
  cliff notes
  notes
  patterns
  programming
  reading journal
  refactoring
  spark notes
  Uncategorized
  </TAGS>
</item>
